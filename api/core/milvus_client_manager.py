"""
MilvusClient API wrapper with BM25 full-text search support

This is the NEW API (Milvus 2.5+) replacing the legacy Collection API.
Supports BM25-based hybrid search (semantic + keyword).
"""
import logging
from typing import Dict, List, Optional
from pymilvus import MilvusClient, DataType, Function, FunctionType
from app.config import settings
from schemas.api.requests.scope import ScopeIdentifier, DataScope
from app.core.auth import UserContext

logger = logging.getLogger(__name__)


class MilvusClientManager:
    """
    MilvusClient API wrapper for BM25 full-text search support

    Key differences from legacy Collection API:
    - Uses MilvusClient instead of connections + Collection
    - Primary key: INT64 with auto_id (instead of VARCHAR)
    - BM25 Function API for sparse vector auto-generation
    - Insert format: list of dicts (instead of column arrays)
    """
    _instance = None
    _client: Optional[MilvusClient] = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

    def get_client(self) -> MilvusClient:
        """Get or create MilvusClient connection"""
        if self._client is None:
            uri = f"http://{settings.MILVUS_HOST}:{settings.MILVUS_PORT}"
            self._client = MilvusClient(uri=uri)
            logger.info(f"âœ… Connected to Milvus via MilvusClient: {uri}")
        return self._client

    def create_collection_with_bm25(self, collection_name: str) -> None:
        """
        Create collection with BM25 full-text search support

        Schema:
        - id: INT64, primary key, auto_id=True (Milvus generates)
        - document_id: VARCHAR(100) - our custom document ID
        - chunk_index: INT64
        - text: VARCHAR(3072), enable_analyzer=True for BM25 tokenization
        - embedding: FLOAT_VECTOR(1536) - dense semantic vector
        - sparse: SPARSE_FLOAT_VECTOR - BM25 sparse vector (auto-generated)
        - metadata: JSON

        Indexes:
        - Dense: HNSW + COSINE metric (semantic search)
        - Sparse: SPARSE_INVERTED_INDEX + BM25 metric (keyword search)

        Args:
            collection_name: Name of collection to create
        """
        client = self.get_client()

        logger.info(f"ðŸ”¨ Creating BM25-enabled collection: {collection_name}")

        # Create schema
        schema = client.create_schema()

        # Primary key - INT64 with auto_id (BM25 recommendation)
        schema.add_field(
            field_name="id",
            datatype=DataType.INT64,
            is_primary=True,
            auto_id=True  # Milvus generates ID automatically
        )

        # Document metadata fields
        schema.add_field(
            field_name="document_id",
            datatype=DataType.VARCHAR,
            max_length=100
        )

        schema.add_field(
            field_name="chunk_index",
            datatype=DataType.INT64
        )

        # Text field with analyzer enabled for BM25 tokenization
        schema.add_field(
            field_name="text",
            datatype=DataType.VARCHAR,
            max_length=3072,  # Optimized from 65535 (21.3x storage reduction)
            enable_analyzer=True  # âœ… Enables tokenization for BM25
        )

        # Dense embedding for semantic search
        schema.add_field(
            field_name="embedding",
            datatype=DataType.FLOAT_VECTOR,
            dim=settings.EMBEDDING_DIMENSION
        )

        # Sparse embedding for BM25 keyword search (auto-generated by Function)
        schema.add_field(
            field_name="sparse",
            datatype=DataType.SPARSE_FLOAT_VECTOR
        )

        # Metadata storage
        schema.add_field(
            field_name="metadata",
            datatype=DataType.JSON
        )

        # Define BM25 function to auto-generate sparse vectors from text
        bm25_function = Function(
            name="text_bm25_emb",
            function_type=FunctionType.BM25,
            input_field_names=["text"],      # Input: text field
            output_field_names=["sparse"]    # Output: sparse vector field
        )
        schema.add_function(bm25_function)
        logger.info(f"âœ… Added BM25 function: text â†’ sparse")

        # Prepare index parameters
        index_params = client.prepare_index_params()

        # Dense vector index (semantic search)
        index_params.add_index(
            field_name="embedding",
            index_type="HNSW",
            metric_type="COSINE",
            params={"M": 16, "efConstruction": 256}
        )
        logger.info(f"âœ… Dense index: HNSW + COSINE")

        # Sparse vector index (keyword search with BM25 scoring)
        index_params.add_index(
            field_name="sparse",
            index_type="SPARSE_INVERTED_INDEX",
            metric_type="BM25",  # âœ… BM25 scoring (only works with Function API)
            params={
                "bm25_k1": 1.2,    # Term frequency saturation parameter
                "bm25_b": 0.75     # Length normalization parameter
            }
        )
        logger.info(f"âœ… Sparse index: SPARSE_INVERTED_INDEX + BM25")

        # Create collection with schema and indexes
        client.create_collection(
            collection_name=collection_name,
            schema=schema,
            index_params=index_params
        )

        logger.info(f"âœ… Successfully created BM25-enabled collection: {collection_name}")

    def get_collection_name(self, scope: ScopeIdentifier) -> str:
        """
        Generate collection name from scope identifier

        Same naming convention as legacy API for compatibility:
        - Private: user_{user_id}_chunks_{dim}
        - Shared: org_{org_id}_shared_chunks_{dim}

        Args:
            scope: Scope identifier

        Returns:
            Collection name string
        """
        return scope.get_collection_name(dimension=settings.EMBEDDING_DIMENSION)

    def has_collection(self, collection_name: str) -> bool:
        """Check if collection exists"""
        client = self.get_client()
        return client.has_collection(collection_name)

    def get_or_create_collection(self, scope: ScopeIdentifier, auto_create: bool = False) -> str:
        """
        Get collection name for scope, optionally creating it

        Args:
            scope: Scope identifier
            auto_create: If True, creates collection if it doesn't exist

        Returns:
            Collection name

        Raises:
            Exception: If collection doesn't exist and auto_create is False
        """
        collection_name = self.get_collection_name(scope)

        if not self.has_collection(collection_name):
            if auto_create:
                logger.warning(f"Collection {collection_name} doesn't exist, creating with BM25...")
                self.create_collection_with_bm25(collection_name)
            else:
                raise Exception(f"Collection '{collection_name}' does not exist")

        return collection_name

    def insert(self, collection_name: str, data: List[Dict]) -> Dict:
        """
        Insert documents into collection

        Data format (list of dicts):
        [
            {
                "document_id": "doc_xxx",
                "chunk_index": 0,
                "text": "chunk text...",
                "embedding": [0.1, 0.2, ...],
                "metadata": {...}
            },
            ...
        ]

        Note:
        - 'id' field NOT included (auto-generated)
        - 'sparse' field NOT included (auto-generated by BM25 function)

        Args:
            collection_name: Target collection
            data: List of document dicts

        Returns:
            Insert result dict with inserted IDs
        """
        client = self.get_client()
        result = client.insert(
            collection_name=collection_name,
            data=data
        )
        logger.info(f"ðŸ’¾ Inserted {len(data)} chunks into {collection_name}")
        return result

    def query(self, collection_name: str, filter: str, output_fields: List[str], limit: int = 100) -> List[Dict]:
        """
        Query documents with metadata filter

        Args:
            collection_name: Collection to query
            filter: Filter expression (e.g., "chunk_index == 0")
            output_fields: Fields to return
            limit: Max results

        Returns:
            List of matching documents
        """
        client = self.get_client()
        return client.query(
            collection_name=collection_name,
            filter=filter,
            output_fields=output_fields,
            limit=limit
        )

    def search(
        self,
        collection_name: str,
        data: List[List[float]],
        anns_field: str = "embedding",
        limit: int = 10,
        output_fields: Optional[List[str]] = None
    ) -> List[List[Dict]]:
        """
        Vector similarity search

        Args:
            collection_name: Collection to search
            data: Query vectors (list of embeddings)
            anns_field: Field to search ("embedding" for dense, "sparse" for BM25)
            limit: Max results per query
            output_fields: Fields to return

        Returns:
            List of search results per query vector
        """
        client = self.get_client()
        return client.search(
            collection_name=collection_name,
            data=data,
            anns_field=anns_field,
            limit=limit,
            output_fields=output_fields or ["*"]
        )

    def drop_collection(self, collection_name: str) -> None:
        """Delete a collection"""
        client = self.get_client()
        client.drop_collection(collection_name)
        logger.info(f"ðŸ—‘ï¸  Dropped collection: {collection_name}")

    def list_collections(self) -> List[str]:
        """List all collection names"""
        client = self.get_client()
        return client.list_collections()

    def describe_collection(self, collection_name: str) -> Dict:
        """Get collection schema and stats"""
        client = self.get_client()
        return client.describe_collection(collection_name)

    def check_health(self) -> dict:
        """
        Check Milvus connection health

        Returns:
            Health status dict
        """
        try:
            client = self.get_client()
            collections = client.list_collections()

            return {
                "status": "connected",
                "message": f"Connected to Milvus (MilvusClient API)",
                "collections_count": len(collections),
                "api_version": "MilvusClient (2.5+)"
            }
        except Exception as e:
            logger.warning(f"Milvus health check failed: {e}")
            return {
                "status": "disconnected",
                "message": f"Cannot connect to Milvus: {str(e)}",
                "collections_count": 0,
                "api_version": "MilvusClient (2.5+)"
            }


# Singleton instance
milvus_client_manager = MilvusClientManager()
